#### 环形链表2 -- 链表，双指针

> 给定一个链表，`返回链表开始入环的第一个节点`
> 如果链表无环，则返回 null

> 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置(索引从0开始)
> 如果 pos 是 -1，则在该链表中没有环

说明: 不允许修改给定的链表

示例1:
    输入: head = [3, 2, 0, -4], pos = 1
    输出: tail connects to node index 1
    解释: 链表中有一个环，其尾部连接到第二个节点
示例2:
    输入: head = [1, 2], pos = 0
    输出: tail connects to node index 0
    解释: 链表中有一个环，其尾部连接到第一个节点
示例3:
    输入: head = [1], pos = -1
    输出: no cycle
    解释: 链表中没有环

进阶: 是否可以不用额外空间解决此题

解题思路:
    环形链表2和1的不同在于，不但要判断链表是否有环，还要返回环开始的第一个位置
    所以先判断链表是否有环，找出环的开始节点

                    -> 5 -> 6 -> 7
    1 -> 2-> 3 -> 4               -> 8
                    <- 10 <- 9 <-

1. 判断有没有环 --- 使用快慢指针的方法 141. 环形链表的步骤
    有两个指针，慢指针和快指针，慢指针每次向前走1步，快指针每次向前走2步
    如果快指针走到了链表的结尾就证明链表是没有环的
    如果有环的话，慢指针和快指针都会进入环中，最后在环中的某个点相遇

2. 计算环开始的位置，在判断链表有环的情况下
    if(!isCycle)
        return null
    接下来为了计算环开始的节点
    `将快指针放回链表的头部`，慢指针每次向前走一步，快指针每次向前也走一步
    当两个指针相遇的时候，相遇的点就是链表中环开始的位置
    fast = head
    while(fast !== slow)
        fast = fast.next
        slow = slow.next
    相遇的位置就是链表中环开始的位置，返回指针即可
    return fast

`弗洛伊德算法`，专门应对环的情况，为什么这个算法是有效的
两个指针都在头部，从头部的节点到环开始的节点的距离是3，环的长度是7
慢指针每次走1步，快指针每次走2步，当慢指针入环的那一刻，慢指针和快指针相差3步
因为快指针每次前进的步数是慢指针的两倍，慢指针走了3步，快指针走了6步
计算他们什么时候相遇，就可以计算一下快指针在环中几步追上慢指针
在环中相当于快指针落后于慢指针7-3=4步
他们会在节点8的位置相遇，然后将快指针移动会头部节点，每次前进一步
此时快指针走3步到达环的开始位置，慢指针走3步也到达环的开始位置，也就是节点4

如果将头部节点到达环开始的节点的距离为 l，那么当慢指针到达环开始节点的位置的时候，
快指针也所在的位置和环节点的距离也是l，整个环的长度为d，
环中剩下的距离就是 d-l，快指针要追赶慢指针的距离就是d-l
当快指针追赶到慢指针相遇的点就是，慢指针从环开始的节点走d-l步这个位置相遇
然后将快指针放到开头，此时d-(d-l)=l就是慢指针回到环开始节点的步数
所以快慢指针会在环的开始位置相遇


```js
/**
*  @param {ListNode} head
*  @return {ListNode}
*/
var detectCycle = function(head) {
    // 先判断是否为空
    if(head === null) {
        return null;
    }

    let slow = head;
    let fast = head;

    // 用来表示链表是否有环
    let isCycle = false;
    
    // 开始循环
    while(fast.next !== null && fast.next.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
        if(slow === fast) {
            isCycle = true;
            break;
        }
    }
    
    // 如果没有环，直接返回空
    if(!isCycle){
        return null;
    }

    // 如果有环，将fast指针移动回头部指针
    fast = head;
    // 开始循环，两个指针都是移动1步，直到他们相遇为止
    while(slow !== fast) {
        slow = slow.next;
        fast = fast.next;
    }
    // 相遇之后直接返回 fast
    return fast;
}
```
