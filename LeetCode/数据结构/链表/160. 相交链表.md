#### 相交链表 -- 链表，双指针
#### 因为两个链表长度不一定相等，不能一个值一个值的对比
#### 开始循环两个指针是否相等两个指针依次移动对比，
#### 如果其中一个指针将一个链表移动完就将回到另一个链表的头部继续移动对比

> 给你两个单链表的头结点 headA 和 headB，请你找出并返回两个单链表相交的起始结点
> 如果两个链表不存在相交结点，返回null 

> 编写一个程序，找到两个单链表相交的起始节点

如下面的两个链表:
A:       a1 -> a2
                   -> c1 -> c2 -> c3
B: b1 -> b2 -> b3
在节点c1开始相交

示例1:
A:      4 -> 1
               -> 8 -> 4 -> 5
B: 5 -> 0 -> 1
    输入: intersectVal = 8, listA = [4, 1, 8, 4, 5],  listB = [5, 0, 1, 8, 4, 5]
            skipA = 2, skipB = 3
    输出: Reference of the node with value = 8
    输入解释: 相交节点的值为8 (注意: 如果两个链表相交则不能为0)
            从各自的表头开始算起，链表 A 为 [4, 1, 8, 4, 5] 链表 B 为 [5, 0, 1, 8, 4, 5]
            在 A 中，相交节点前有 2 个节点，在B中，相交节点前有 3 个节点

注意:
    * 如果两个链表没有交点，返回 null
    * 在返回结果后，两个链表仍须保持原有的结构
    * 可假定整个链表结构中没有循环
    * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存

`A和B的长度不一样，所以不能一一对比`

1. 设置 n1，n2 两个指针，let n1 = headA; let n2 = headB;

2. 循环，如果不相等指针就向下移动继续判断 while(n1 !== n2) 
    判断指针 n1 是否移动到链表的最后，如果移动到链表的最后
    就将指针 n1 的位置换成 链表B的头部，否则指针 n1 继续向下移动
    if(n1 === null){
        n1 = headB
    }else {
        n1 = n1.next
    }
    同理 指针 n2也用相同的方式来判断
    if(n2 === null) {
        n2 = headA;
    }else{
        n2 = n2.next;
    }
3. 移动到循环外就表示找到了相交链表的位置直接返回指针即可 return n1;

解题思路:
A:       a1 -> a2
                   -> c1 -> c2 -> c3
B: b1 -> b2 -> b3

n1，n2两个指针，思路依然是两个指针一个一个的向前移动，移动完后对比当前指针所在的节点是否相等
a1是否等于b1，不相等，两个指针n1，n2就向前移动
a2是否等于b2，不相等，两个指针n1，n2继续向前移动
直到n1移动到链表最后节点的后面也就是空节点，n2移动到c2节点
A链表已经走完，将指针n1移动到B链表的头部，然后n2指针移动完后也移动到A链表的头部再依次做比较
当n1和n2移动到同一个节点，就是两个链表相交的位置节点


```js
/**
*  Definition for singly-linked list
*  function ListNode(val){
*       this.val = val;
*       this.next = null;  
*  }
*/
/**
*  @param {ListNode} headA  
*  @param {ListNode} headB
*  @return {ListNode}
*/
var getIntersectionNode = function(headA, headB) {
    let n1 = headA;
    let n2 = headB;

    while(n1 !== n2) {
        // 如果n1走到结尾的话，就将他定义到链表B的头部，否则的话向前移动
        if(n1 === null) {
            n1 = headB;
        }else{
            n1 = n1.next
        }
        if(n2 === null) {
            n2 = headA;
        }else{
            n2 = n2.next;
        }
    }

    // 循环外就表示他们已经相交
    return n1;

    // 如果两个链表不想交的情况已经被包含在算法里面了，
    // 如果两个链表不想交指针n1会走完A再走完B，这种情况最后n1会指向空值
    // n2最后也会指向空值，最后空值等于空值，会跳出循环，返回的也是空值
}
```