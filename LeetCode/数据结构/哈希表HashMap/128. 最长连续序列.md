#### 最长连续序列 -- 数组，并查集，Set集合
#### `实质是找到起点，判断有没有连续值，也就是判断数组中一个值有没有左右连续值，右连续值最长多少`
> 给定一个未排序的整数数组 nums，找出数字连续的最长序列(不要求序列元素在原数组中连续)的长度

示例1:
    输入: nums = [100, 4, 200, 1, 3, 2]
    输出: 4
    解释: 最长数字连续序列是 [1, 2, 3, 4] 他的长度是 4
示例2:
    输入: nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1]
    输出: 9

解题思路:

    Set的查找，时间复杂度是 O(1) 

    1. 使用Set()去掉重复的元素，将数组放入Set中，遍历数组 nums
        创建变量 max 保存最大的连续序列长度
    2. 先找到当前项是不是连续序列的起点
        如果 当前项减1 存在于 Set，说明当前项不是连续序列的起点，跳过，继续遍历
        当前项没有'左邻居'，就是连续序列的起点
    3. 不断在set中查看 cur+1 是否存在，也就是检查cur有没有右邻居连续，存在的话，count+1
    4. 当 cur 不再有'右邻居'，就算出了一段连续序列的长度
    5. 使用Math.max() 判断当前的连续长度和之前的比是不是最长的长度，赋值给变量max
```js
var longestConsecutive = (nums) => {

    const set = new Set(nums)
    let max = 0
    
    for(let i = 0; i < nums.length; i++) {
        // 判断 nums[i] 是不是起点，有没有左邻居，如果没有从该 nums[i] 开始循环查找
        // 使用 set.has() 方法
        if(!set.has(nums[i] - 1)) {

            // cur为当前值，第一次赋值的时候就是该序列的起点
            let cur = nums[i];
            let count = 1;
            
            // 开始向后查找从该 nums[i] 开始有没有右邻居
            while(set.has(cur + 1)) {
                cur++
                count++
            }

            // 循环结束后，判断count是否最大然后赋值给max
            max = Math.max(max, count)
        }
    }
    return max
}

```