### 哈希表扩容的思想
* 为什么需要扩容?
  * 目前，我们是将所有的数据项放在长度为7的数组中的
  * 因为我们使用的是链地址法，loadFactor(就是count和limit比值)可以大于1所以这个哈希表可以无限制的插入新数据
  * 但是，随着数据量的增多，每一个index对应的bucket会越来越长，也就造成效率的降低
  * 所以，在何时的情况对数组进行扩容，比如扩容两倍
* 如何进行扩容?
  * 扩容可以简单的将容量增大两倍(不是质数? 质数的问题后面再争论)
  * 但是这种情况下，所有的数据项一定要同时进行修改(重新调用哈希函数，来获取不同的位置)
  * 比如hashCode = 12的数据项，在length=8的时候，index=4，在长度为16的时候呢? index=12
  * 这是一个耗时的过程，但是如果数组需要扩容，那么这个过程是必要的
* 什么情况下扩容呢?
  * 比较常见的情况是loadFactor > 0.75的时候进行扩容
  * 比如Java的哈希表就是装填因子大于0.75的时候，对哈希表进行扩容

### 哈希表扩容实现
先创建一个新的变量oldStorage，让他指向现在的数组，同时this.storage也指向数组
直接将this.storage 赋值个 oldStorage 也指向数组
现在让this.storage 指向一个新的创建的数组，所以现在只有oldStorage指向数组
从oldStorage里面把每个bucket全部都取出来，再将元素都取出来，插入到新的里面
1. 先将之前数组保存起来，因为我们待会将stroage = []
2. 之前的属性值需要重置
3. 遍历所有的数据项，重新插入到哈希表中

#### 普通判断质数算法
#### 容量质数
* 我们前面提到过，容量最好是质数
  * 虽然在链地址法将容量设置为质数，没有在开放地址法中重要
  * 但是其实链地址法中质数作为容量也更便利于数据的均匀分布，所以，我们还是完成一下这个步骤
* 先讨论一个常见的面试题，判断一个数是质数，只能被1和自己整除，不能被2到num-1之间的数字整除
```js
function isPrime(num){
    for(var i = 2; i < num; i++){
        if(num % i == 0){ // 表示num被整除，表示不是质数
            return false
        }
    }
    return true
}
alert(isPrime(3))
alert(isPrimse(32))
alert(isPrimse(37))
```
* 质数的特点
  * 质数也成为素数
  * 质数表示大于1的自然数中，只能被1和自己整除的数
#### 高效判断质数算法
* 之前的做法效率并不高
  * 对于每个数n，其实并不需要从2判断到n-1
  * 一个数若可以进行因数分解，那么分解时得到的两个数一定是一个小于等于sqrt(n)，一个大于等于sqrt(n)
  * 比如16可以被分解，那么是2*8，小于sqrt(16)，也就是4 ， 8 大于4。而4*4都是等于sqrt(n)
  * 所以只需要判断到开平方根的那个位置即可，我们遍历到等于sqrt(n)即可
```js
function isPrime(num){
    // 1. 获取平方根，parseInt()将获得到的平方根转化为整数
    var temp = parseInt(Math.sqrt(num))
    // 2. 循环判断
    for(var i = 2; i<=temp; i++){
        if(num % i == 0){
            return false
        }
    }
    return true
}
```
#### 实现容量恒为质数
之前每次扩容的时候，把原来的容量*2，要将limit的结果转化成最接近的质数
