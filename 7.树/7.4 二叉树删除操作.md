### 二叉搜索树的删除操作分析
                            11

            7                                 18
    
    5               9                 13              20

3               8       10      12          14    18        25

                                                      19

* 二叉搜索树的删除有些复杂，分成很多种情况
* 删除节点要从查找要删的节点开始，找到节点后，需要考虑三种情况:
  * 该节点是叶节点(没有子节点，比较简单)
  * 该节点有一个子节点(也相对简单)
  * 该节点有两个子节点(情况比较复杂)
* 先从查找要删除的节点开始
* 代码思路
  1. 先找到要删除的节点，如果没找到，不需要删除
  2. 找到要删除的节点，
       * 删除叶子节点
       * 删除只有一个子节点的节点
       * 删除有两个子节点的节点
1. 情况一: 没有子节点
   * 这种情况相对比较简单，我们需要检测current的left以及right是否都为null
   * 都为null之后还有检测一个东西，就是是否current就是根，都为null，并且为根，
     那么相当于要清空二叉树(只是清空了根，因为只有他)
   * 否则就把父节点的left或right字段设置为null即可
   * 如果只有一个单独的根，直接删除即可
   * 如果是叶节点，那么处理方式如下:     叶子节点就是左右子节树都为空
     * 如果是3，8，10，12，14，18，25中任何一个叶子节点(current)
        那么直接将parent(current的父节点)指向该引用的left或right，设置为空null节点即可
2. 情况二: 删除的节点只有一个子节点
   * 直接将该节点的父节点指向该节点的那个唯一的子节点即可，就可以删除要删除的节点
   * 要删除的current节点，只有2个连接(如果有两个子节点，就是三个连接了)，
     一个连接父节点，一个连接唯一的子节点
   * 需要从这三者之间: 爷爷 - 自己 - 儿子，将自己(current)剪短，让爷爷直接连接儿子即可
   * 这个过程要求改变父节点的left或者right，指向要删除的节点的子节点
     * 假设要删除的是节点 5， 而5只有一个子节点
     * 其实无所谓自己的子节点3还有没有子节点，直接将该节点移到原来5的位置即可
     * 也就是让父节点7，直接指向3节点
   * 当然，这个过程还要考虑是否current就是根
   * 图解过程:
     * 如果是根的情况，....
     * 如果不是根，并且只有一个子节点的情况
3. 情况三: 删除的节点有两个子节点
   1. 情况1: 删除9节点，这个节点的左右子节点都是叶子节点，8和10之后就没有继续的子节点
         * 处理方式相对简单，将8位置替换到9，或者将10位置替换到9
         * 注意: 这里说的是替换，也就是8位置替换到9时，7指向8，而8还需要指向10
   2. 情况2: 删除7节点，这个节点的左子节点5还有一个左子节点3，右子节点9分别有一个左子节点8和一个右子节点10
         * 第一种方式将5拿到7的位置，3依然指向5，但是5有一个right需要指向9，依然是二叉搜索树，没有问题
         * 另一种方式，找到右子节点的左子节点8，也就是将8替换到7的位置，8的左子节点指向5，右子节点指向9
   3. 情况3: 删除节点15，这个节点的左子节点13分别有左子节点12和右子节点14，
            15的右子节点20分别有左子节点18和右子节点25，他的左子节点18还有一个右子节点19
         * 第一种方式在删除节点的左子节点查找将删除节点的左子节点的右子节点14与删除节点15替换即可
         * 第二种方式在删除节点的右子节点查找，将删除节点的右子节点的左子节点18与删除节点15替换
              此时，18的右子节点19如何处理?  18节点不可能有左子节点，只能有右子节点
              因为如果18有左子节点，与删除节点替换的就不可能是18，而是他的左子节点，
              所以18的右子节点19提到原来18的位置，作为20的左子节点
         * 总结规律:
              * 如果我们要删除的节点有两个子节点，甚至子节点还有子节点，
                这种情况需要从下面的子节点中找到一个节点来替换当前的节点
              * 但是找到的这个节点有什么特征呢? 应该是current节点下面所有节点中最接近current节点的
                * 要么比current节点小一点点，要么比current大一点点的
                * 总结你最接近current，你就可以用来替换current的位置
              * 这个节点怎么找呢?
                * 比current小一点点的节点，一定是current左子树的最大值
                * 比current大一点点的节点，一定是current右子树的最小值
              * 前驱&后继
                * 在二叉搜索树中，这两个特别的节点，有两个特别的名字
                * 比current小一点点的节点，称为current节点的前驱
                * 比current大一点点的节点，称为current节点的后继
              * 也就是为了能够删除有两个子节点的current，要么找到他的前驱，要么找到他的后继
              * 所以接下来，先找到这样的节点(前驱或后继都可以，这里以找后继为例)
### 删除节点的总结和思考
* 实际上，因为它非常复杂，一些程序员尝试着避开删除操作
  * 他们的做法是在Node类中添加一个boolean的字段，比如名称为isDeleted
  * 要删除一个节点时，就将此字段设置为true
  * 其他操作，比如find()在查找之前先判断这个节点是不是标记为删除
  * 这样相对比较简单，每次删除节点不会改变原有的树结构
  * 但是在二叉树的存储中，还保留着哪些本该已经被删除掉的节点
* 上面的做法看起来很聪明，其实是一种逃避
  * 这样会造成很大空间的浪费，特别是真毒数据量较大的情况
  * 而且，作为程序员要学会通过这些复杂的操作，段落自己的逻辑
```js
//删除节点
BinarySearchTree.prototype.remove = function(){
    // 1. 寻找要删除的节点
    // 1.1 定义临时保存的变量
    var current = this.root
    var parent = this.root
    var isLeftChild = true
    // 1.2 开始查找节点
    while(current.key !== key){
        parent = current
        if(key < current.key){
            isLeftChild = true
            current = current.key
        }else{
            isLeftChild = false
            current = current.right
        }
        // 如果发现current已经指向null，那么说明没有找到要删除的数据
        if(current === null) return false
    }
    return true
}
```
```js
// 找后继的方法
BinarySearchTree.prototype.getSuccessor = function(delNode){
  // 1. 使用变量保存临时的节点
  var successorParent = delNode
  var successor = delNode
  var current = delNode.right  // 要从右子树开始查找
  // 2. 寻找节点
  while(current != null){
    successorParent = successor
    successor = current 
    current = current.left
  }
  // 3. 如果是删除图中15的情况，还需要如下代码
  if(successor != delNode.right){
    successorParent.left = successorParent.right
    successor.right = delNode.right
  }
}
```