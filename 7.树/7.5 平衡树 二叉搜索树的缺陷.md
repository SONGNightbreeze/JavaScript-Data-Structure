* 二叉搜索树作为数据存储的结构有重要的优势:
  * 可以快速地找到给定关键字的数据项 并且可以快速地插入和删除数据项
  * 速度取决于二叉搜索树的深度，深度越小查找的次数越少
* 但是，二叉搜索树有一个很麻烦的问题:
  * 如果插入的数据是"有序"的数据，比如下面的情况
    * 有一颗初始化为 9 8 12 的二叉树
    * 插入下面的数据 7 6 5 4 3
* 非平衡树:
  * 数据项插入的顺序会影响二叉搜索树的分布
  * 比较好的二叉搜索树数据应该是左右分布均匀的
  * 但是插入连续数据后，分布的不均匀，称这种树为非平衡树
  * 对于一棵平衡二叉树，插入/查找等操作的效率是 O(logN)
  * 对于一棵非平衡二叉树，相当于编写了一个链表，查找效率变成了饿 O(N)
* 为了能以较快的时间 O(logN)来操作一棵树，我们需要保证树总是平衡的:
  * 至少大部分是平衡的，那么时间复杂度也是接近 O(logN)的
  * 也就是说树中每个节点左边的子孙节点的个数，应该尽可能的等于右边的子孙节点的个数
  * 常见的平衡树?
* AVL树(现在实际开发中已经很少应用)
  * AVL树是最早的一种平衡树，他有些办法保持树的平衡(每个节点多存储了一个额外的数据)
  * 因为AVL树是平衡的，所以时间复杂度也是 O(logN)
  * 但是，每次插入/删除操作相对于红黑树效率都不高，所以整体效率不如红黑树