### 红黑树
* 数据结构中难点中的难点
* 红黑树，除了符合二叉搜索树的基本规则外，还添加了以下特性:
    1. 节点是红色或黑色
    2. 根节点是黑色
    3. 每个叶子节点左右子节点使用黑色的空节点来补齐(NIL节点)，
        意味着每个节点都要有左右子节点，如果没有的话使用黑色的空节点NIL来补齐
    4. 每个红色节点的两个子节点都是黑色，(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
### 红黑树的相对平衡
* 前面的约束，确保了红黑树的关键特性:
  * 从根到叶子的最长可能路径，不会超过最短可能路径的两倍长
  * 结果就是这个数基本是平衡的
  * 虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是高效的
* 为什么可以做到 最长路径不超过最短路径的两倍 呢?
  * 性质4决定了路径不能有两个相连的红色节点
  * 最短的可能路径都是黑色节点
  * 最长的可能路是红色和黑色交替
  * 性质5所有路径都有相同数目的黑色节点
  * 这就表明了没有路径能多余任何其他路径的两倍长
### 红黑树变换之变色
* 插入一个新节点时，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡: 换色-左旋转-右旋转
* 变色: 为了重新符合红黑树的规则，尝试把红色节点变成黑色，或者把黑色节点变为红色
* 首先，需要知道插入的新节点通常都是红色节点:
    * 因为在插入节点为红色的时候，有可能插入一次是不违反红黑树任何规则的
    * 而插入黑色节点，必然会导致有一条路径上多了黑色节点，这是很难调整的
    * 红色节点可能导致出现红红相连的情况，但是这种情况可以通过颜色调整和旋转来调整
### 红黑树变换之旋转
* 左旋转
* 逆时针旋转红黑树的两个节点，使得父节点被自己的右子节点取代，而自己成为自己的左子节点
            x                               y
        
        a       y             ==>       x       c

            b       c               a       b
* 图中，身为右子节点的y取代了x的位置，而x变成了y的左子节点，此为左旋转 
* 右旋转
* 顺时针旋转红黑树的两个节点，使得父节点被自己的左子节点取代，而自己成为自己的右子节点
            x                               y
        
        y       a             ==>       b       x

    b       c                               c       a
* 图中，身为左子节点的y取代了x的位置，而x变成了y的右子节点

### 红黑树 变换规则
* 插入操作
* 设要插入的节点为N，其父节点为P
* 其祖先节点为G，其父亲的兄弟节点为U (即P和U是同一个节点的子节点)
* 情况1:
  * 新节点N位于树的根上，没有父节点
  * 这种情况下，我们直接将红色变成黑色即可，这样满足性质2
* 情况2:
  * 新节点的父节点P是黑色
  * 性质4没有失效(新节点是红色的)，性质5也没有任何问题
  * 尽管新节点N有两个黑色的叶子节点nil，但是新节点N时红色的，所以通过它的路径中黑色节点的个数依然相同
    满足性质5

* 情况3:
  * P是红色节点，U也是红色节点，也就是父节点和叔叔节点都是红色，祖先节点一定是黑色
  * 操作方案:
    * 将P父节点和U叔叔节点变换为黑色，并且将G祖先节点变换为红色
    * 现在新节点N有了一个黑色的父节点P，所以每条路径上黑色节点的数目没有改变
    * 而从最高的路径上，必然都会经过G节点，所以那些路径的黑色节点数目也是不变的，符合性质5
  * 可能出现的问题:
    * 但是，N的祖先节点G的父节点也可能是红色，这就违反了性质3，==> 可以"递归的调整颜色"
    * 但是如果递归调整颜色到"根节点"，就需要进行旋转了，之后的例子中遇到的问题

* 情况4:
  * N的父节点P是红色，叔叔节点U是黑色，祖先节点G是黑色，并且N是左子节点
  * 操作方案:  1. 父节点P变成黑色 2. 祖先节点G变成红色 3. 进行右旋转
    * 交换以前的父节点P和祖先节点G的颜色 (父节点P由红色变成黑色，祖先节点G由黑色变成红色)
    * 对祖先节点G进行依次的右旋转
      * 在右旋转的树中，以前的父节点P旋转是新节点，是以前祖先节点G的父节点
      * B节点向右平移，成为G节点的左子节点
        G                       G                       P                         

    P       U       ==>     P       U       ==>     N       G

N       B               N       B                       B       U

* 情况5:
  * N的父节点P是红色，叔叔节点U是黑色节点，祖先节点是黑色，N是右子节点
  * 操作方案: 1. 以P为根左旋转，将P作为新插入的红色节点考虑即可 变成情况4
               2. 自己变成黑色，祖先节点变成红色 3. 以祖先节点为根，进行右旋转
    * 对P节点进行依次左旋转，形成情况4的结果
    * 对祖先节点G进行依次右旋转，并且改变颜色即可
        G                           G                           N
                    变成情况4
    P       U       ==>         N       U       ==>         P       G

B       N                   P                           B               U

                        B
### 红黑树 案例练习 1
* 案例: 10 9 8 7 6 5 4 3 2 1 
  如果使用普通二叉树插入的话，会全部插入到左边，作为左子节点，就变成链表的形式，所以要使用红黑树
  做任何操作都会效率特别低，因为是以链表的形式做操作。
* 插入 10
  * 插入节点10，将节点10的颜色改成黑色
* 插入 9
  * 符合规则2，不需要任何变化
  * 规则1，节点是红色，根节点是黑色，
  * 每一个节点都由叶子节点Null，即节点9有两个Null叶子节点，根节点10有一个右子节点Null，符合规则3
  * 规则4，每个红色节点，都有两个子节点为黑色
  * 规则5，从任何一个节点到叶子节点所经过的黑色节点的数目都是相同的
* 插入 8
  * 创建8的新节点，为红色
  * 将8插入到节点9的左子节点，就变成情况4
    * 节点8的父节点9变成黑色，祖先元素10变成红色
    * 右旋转，父节点9变成根节点，节点8依然是9的左子节点，原来的祖先节点10变成父节点9的右子节点
    * 符合所有规则
        10 (空白位置是黑色Null)      9
    
    9               ==>         8       10

8

* 插入7 
  * 创建7的新节点，红色
  * 将7插入到节点8的左子节点，变成了情况3，父节点红色，叔叔节点红色，祖先节点黑色
    * 将节点7的父节点8变成黑色，叔叔节点10变成黑色，祖先节点9(也是根节点)变成红色
    * 现在不符合"规则2"，根节点永远是黑色，将根节点变成黑色即可

* 插入6
  * 创建6的新节点，红色
  * 将6插入到节点7的左子节点，不符合规则4，现在节点7和节点6都是红色
  * 变成了情况4，插入节点的父节点为红色，叔叔节点为黑色，祖先节点为黑色
    * 父节点7变成黑色，祖先节点变成红色
    * 进行右旋转
      * 以祖先节点8为轴进行右旋转，将节点7提升，节点8下降
            9                                 9

        8       10          =>            7       10 
    
    7                                 6       8
    
6

* 插入5
  * 创建5的新节点，红色
  * 将5插入到节点6的左子节点，不符合规则3，父节点红色，叔叔节点黑色，祖先节点黑色
    *  将节点5的父节点6变成红色，叔叔节点8变成黑色，祖先节点7变成红色

* 插入4
  * 创建4的新节点，红色
  * 将4插入到节点5的左子节点，两个红色节点4，5相连，
    * 情况4，插入节点的父节点为红色，叔叔节点为黑色，祖先节点为黑色
    * 父节点5变成黑色，祖先节点6变成红色
    * 进行右旋转
      * 以祖先节点6为轴进行右旋转，将节点5提升，节点6下降
      * 现在变成5是父节点，左子节点为4，右子节点为6
                9                                       9

            7       10                              7       10

        6       8               =>              5       8

    5                                       4       6

4

* 插入3 两次变化
  * 创建3的新节点，红色
  * 将3插入到节点4的左子节点
  * 第一次变化，情况3，将父节点4变成黑色，叔叔节点6变成黑色，祖先节点5变成红色
  * 现在祖先节点5和他的父节点7都是红色相连，所以现在以节点5为当前节点来变化
  * 第二次变化，情况4
    * 以节点5为当前节点，他的父节点7变成黑色，祖先节点9变成红色，
    * 进行右旋转
      * 以祖先节点9(也是根节点)进行右旋转，将父节点7提升，祖先节点9下降
                    9                                     7
                
                7       10          =>              5           9

            5       8                            4     6     8     10

        4       6                            3

    3

* 插入2
  * 创建2的新节点，红色
  * 将2插入到节点3的左子节点，情况4
    * 将父节点3变成黑色，祖先节点4变成红色
    * 右旋转  
      * 以祖先节点4进行右旋转，父节点3提升，祖先节点4下降
                     7                                          7

                5          9                              5             9
            
            4       6   8     10        =>           3        6      8      10
          
        3                                        2       4

    2

* 插入3
  * 创建1的新节点，红色
  * 将1插入到节点2的左子节点，符合情况3
    * 第一次变换，情况3，父节点2变成黑色，叔叔节点4变成黑色，祖先节点3变成红色
    * 现在节点3和他的父节点5都是红色，所以以节点3为当前节点
      * 是情况3，父节点5和叔叔节点9都是红色，祖先节点7黑色
      * 第二次变换，将父节点5和叔叔节点9变成黑色，祖先节点7变成红色
      * 祖先节点7就是根节点，不符合规则2，根节点永远是黑色
        * 将组件节点7(根节点)变成黑色即可

### 删除&代码
* 红黑树的删除
  * 已经学过了二叉搜索树的删除操作，比较复杂
  * 已经学过了红黑树的插入规则，比较复杂
  * 红黑树的删除操作，两个复杂的操作结合起来，难度很大
* 插入和删除的代码实现:
  * 插入的步骤已经一步步的进行分析
  * 分析完成后，写出插入的代码并不是很难
  * 删除也需要按照插入一样，分成很多情况，然后写出最终的代码形式
* 目前，已经讲解了树的很多知识，作为前端数据结构和算法的补充，先到这里，
  * 至于，红黑树的删除代码，可以用Java，Python来实现