### 冒泡排序
* 冒泡排序算法相对其他排序运行效率较低，但是在概念上他是排序算法中最简单的
  * 因此，冒泡排序时在刚开始学习排序时，最适合学习的一种排序方式
* 冒泡排序的思路:
  * 对未排序的各元素从头到尾依次比较相邻的两个元素大小关系
  * 如果左边的队员高，则两队员交换位置
  * 向右移动一个位置，比较下面两个队员
  * 当走到最右端时，最高的队员一定被放在了最右边
  * 按照这个思路，从最左端重新开始，这次走到倒数第二个位置的队员即可
  * 依次类推，就可以将数据排序完成
* 代码思路分析:
  * 第一次找出最高人放在最后，我们需要两个两个数据项进行比较，这个应该是一个循环操作
  * 第二次将次高的人找到放在倒数第二个位置，也是两个比较，只是不要和最后一个比较(少了一次)，
    但是前面的两个两个比较也是一个循环操作
  * 第三次...第四次...
  * 这应该是一个循环中嵌套循环，并且被嵌套的循环次数越来越少的
  * 根据这个分析来实现代码 


#### 创建一个列表封装我们的数据项
```js
// 创建列表类
function ArrayList(){
    // 属性
    this.array = []
    // 方法
    // 将数据可以插入到数组中的方法
    ArrayList.prototype.insert = function(){
        this.array.push(item)
    }
    // toString  调用上面insert方法的时候，toString方法也会执行
    ArrayList.prototype.toString = function(){
        return this.array.join('-')
    }
    // 交换数据的方法
    ArrayList.prototype.swap = function(m,n){
      var temp = this.array[m]
      this.array[m] = this.array[n]
      this.array[n] = temp
    }

    // 实现排序算法
    // 冒泡排序
    ArrayList.prototype.bubbleSort = function(){
      // // 1. 获取数组的长度
      // var length = this.array.length;
      // // 第一次进来:   i = 0，比较 0 和 1 位置的两个数据，如果0位置大于1位置的数据
      // // 最后一次进来: i = length - 2，比较 length - 2 和 length -1 的两个数据 
      // for (var i = 0; i < length - 1: i++){
      //   if(this.array[i] > this.array[i+1]){
      //     // // 两两交换，交换两个数据
      //     // var temp = this.array[i]
      //     // this.array[i] = this.array[i+1]
      //     // this.array[i+1] = temp
      //     // // 交换数据的方法经常使用，所以可以定义成函数

      //     // 交换两个数据 
      //     this.swap(i,i+1)
      //   }
      // } // 一层循环只是将最大的值放到了最右边，
           // 接下来还要将第二大的位置放在倒数第二个位置，依次类推所以外层还要嵌套一层for循环
      
      // 第一次: j = length - 1，比较到倒数第一个位置
      // 第二次：j = length - 2, 比较到倒数第二个位置
      // ...
      var length = this.array.length;
      for (var j = length -1; j >= 0; j--){
        for(var i = 0; i < j; i++ ){
          if(this.array[i] > this.array[i+1]){
            this.swap(i,i+1)
          }
        }
      }
    }

    // 选择排序
    ArrayList.prototype.selectionSort = function(){
      // 1. 获取数组长度
      var length = this.array.length
      
      // // 2. 选定第一个索引位置
      // var min = 0
      // // 遍历数组，分别与第一个索引位置比较
      // for(var i = min + 1; i < length; i++){
      //   if(this.array[min] > this.array[i]){
      //     // 如果min位置的值大于数组中的值，将索引位置赋值给min，找出最小的值
      //     min = i
      //   }
      // }
      // // 第一轮找到后，将最小的位置min和第一个位置交换
      // this.swap(min,0)
      // // 如果想依次后面继续排序，再在外层嵌套一层循环即可

      // 2. 外层循环从0位置开始取数据
      for (var j = 0; j < length - 1; j++){
        var min = j
        // 内层循环，从i+1位置，开始和后面的数据进行比较
        for(var i = min + 1; i < length; i++){
          if(this.array[min] > this.array[i]){
            min = i
          }
        }
        this.swap(min, j)
      }
    }
    // 插入排序
    ArrayList.prototype.insertionSort = function(){
      // 1. 获取数组的长度
      var length = this.array.length
      // 2. 外层循环: 从第1个位置开始获取数据，向前面局部有序插入
      for(var i = 1; i<length; i++){
        // 3. 内层循环: 获取i位置的元素，和前面的数据依次进行比较
        var temp = this.array[i]
        var j = i
        // 因为不知道比较次数，所以使用while不用for
        // this.array[j-1] 就是i前面的那个位置数据
        while(this.array[j - 1] > temp && j > 0){
          // 如果前面位置的数据大于现在位置的数值，就进行一个位移
          this.array[j] = this.array[j - 1]
          j--
        }
        // 4. 将j位置的数据，放置temp就可以了
        this.array[j] = temp
      }
    }
}

// 测试类
var list = new ArrayList()
// 插入元素
list.insert(66)
list.insert(88)
list.insert(12)
list.insert(87)
list.insert(100)
list.insert(5)
list.insert(566)
list.insert(23)
alert(list)  // 输出 66-88-12-87-100-5-566-23
// 测试冒泡排序
list.bubbleSort()
alert(list)
// 测试选择排序
list.selectionSort()
alert(list)
```

### 冒泡排序

```js
ArrayList.prototype.bubbleSort = function(){
  // 1. 获取数组的长度
  var length = this.array.length
  // 2. 反向循环，因此次数越来越少
  for (var i = length - 1; i>= 0; i--){
    // 3. 根据i的次数，比较循环到i位置
    for(var j = 0; j < i; j++){
      // 4. 如果j位置比j+1位置的数据大，那么就交换
      if(this.array[j] > this.array[j+1]){
        // 交换
        this.sway(j, j+1)
      }
    }
  }
}
ArrayList.prototype.swap = function(m,n){
  var temp = this.array[m]
  this.array[m] = this.array[n]
  this.array[n] = temp
}
```
* 代码解析:
  * 代码序号1: 获取数组的长度
  * 代码序号2: 我们现在要写的外层循环，外层循环应该让i依次减少，因此我们这里使用了反向的遍历
  * 代码序号3: 内层循环、内层循环使用j < i，因为上面的i在不断减少，这样就可以控制内层循环的次数
  * 代码序号4: 比较两个数据项的大小，如果前面的大，那么就进行交换

#### 冒泡排序的效率
* 冒泡排序的比较次数:
  * 如果按照上面的例子来说，一共有7个数字，那么每次循环时进行了几次比较呢?
  * 第一次循环6次比较，第二次5次比较，第三次4次比较...直到最后一趟进行了一次比较
  * 对于7个数据项比较次数: 6 + 5 + 4 + 3 + 2 + 1
  * 对于N个数据项呢? (N-1) + (N-2) + (N-3) +... + 1 = N*(N-1)/2
* 通过大O表示法推导过程，推导一下冒泡排序的大O形式:
  * N * (N-1)/2 = N^2/2 - N/2 根据规则2，只保留最高阶项，变成N^2/2
  * N^2/2，根据规则3，去除最高项的常量，变成N^2
  * 如果有两次比较才需要交换一次(不可能每次都比较都交换一次)，那么交换次数为1/4
  * 由于常量不算在大O表示法中，因此，我们可以认为交换次数的大O表示也是O(N^2)

### 选择排序
* 选择排序改进了冒泡排序
  * 将交换的次数有O(N^2)减少到O(N)
  * 但是比较的次数依然是O(N^2)
* 选择排序的思路:
  * 选定第一个索引位置，然后和后面元素依次比较
  * 如果后面的队员，小于第一个索引位置的队员，则交换位置
  * 经过一轮的比较后，可以确定第一个位置是最小的
  * 然后使用同样的方法把剩下的元素逐个比较即可
  * 可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后
```js
ArrayList.prototype.selectionSort = function(){
  // 1. 获取数组的长度
  var length = this.array.length
  // 2. 外层循环: 从0位置开始取出数据，直到length-2位置
  for( var i = 0; i < length-1; i++){
    // 3. 内层循环，从i+1位置开始，和后面的内容比较
    var min = i
    for( var j = 0; j < length; j++){
      // 4. 如果i位置的数据大于j位置的数据，那么记录最小的位置
      if(this.array[min] > this.array[j]){
        min = j
      }
    }
    // 5. 交换min和i位置的数据
    this.swap(min,i)
  }
}
```
### 代码实现
* 代码解析
  * 代码序号1: 依然获取数组的长度
  * 代码序号2: 外层循环，需要从外层循环的第0个位置开始，依次遍历到length-2的位置
  * 代码序号3: 先定义一个min，用于记录最小的位置，内层循环，内层循环时从i+1位置开始的数据项，
              和i位置的数据项依次比较，直到length-1的数据项
  * 代码序号4: 如果比较的位置i的数据项，大于后面某一个数据项，那么记录最小位置的数据
  * 代码序号5: 将min位置的数据，那么i位置的数据交换，那么i位置就是正确的数据了
  注意: 这里的交换是基于之前的交换方法，这里直接调用即可


### 选择排序的效率
* 选择排序的比较次数:
  * 选择排序和冒泡排序的真实次数都是: N*(N-1)/2，
  * 大O表示法就是: O(N^2)
* 选择排序的交换次数:
  * 选择排序每次进行选择的时候，最多需要交换1次，一共遍历多少次? N-1次
  * 选择排序的交换次数只有N-1次，用大O表示法就是O(N)
  * 比较次数与冒泡排序相同，但是选择排序少于冒泡排序
  * 所以选择排序通常认为在执行效率上是高于冒泡排序的


### 插入排序
* 插入排序是简单排序中效率最好的一种
  * 插入排序也是学习其他高级排序的基础，比如希尔排序/快速排序，所以也非常重要
* 插入排序的思路
* 局部有序:
  * 插入排序思想的核心是局部有序，什么是局部有序?
  * 比如在一个队列中的人，我们选择其中一个作为标记的队员
  * 这个被标记的队员左边的所有队员已经是局部有序的
  * 这就意味着，有一部门人是按顺序排列好的，有一部分还没有顺序
* 插入排序的思路:
  * 从第一个元素开始，该元素可以认为已经被排序
  * 取出下一个元素，在已经排序的元素序列中从后向前扫描
  * 如果该元素(已排序)大于新元素，将该元素移到下一位置
  * 重复上一个步骤，直到找到已排序的元素小于或者等于新元素的位置
  * 将新元素插入到该位置后，重复上面的步骤

### 代码思路分析
* 插入排序应该从下标值1开始(因为0位置默认可以被认为是有序的)
* 从1位置开始取出元素，并且判断该元素的大小和0位置进行比较，如果1位置元素小于0位置元素，那么交换
  否则不交换
* 上面步骤执行完成后， 0 - 1位置已经排序好
* 取出2位置的元素，和1位置进行比较
  * 如果2位置元素大于1位置元素，说明2位置不需要任何动作，0 - 1 - 2已经排序好
  * 如果2位置元素小于1位置元素，那么将1移动到2的位置，并且2继续和0进行比较
  * 如果2位置元素大于0位置的元素，那么将2位置放置在1的位置，排序完成 0 - 1 - 2搞定
  * 如果2位置元素小于1位置的元素，那么将0位置的元素移动到1位置，并且将2位置的元素放在0位置
    0 - 1 - 2搞定
* 按照上面的步骤，依次找到最后一个元素，整个数组排序完成

```js
ArrayList.prototype.insertionSort = function(){
  // 1. 获取数组的长度
  var length = this.array.length
  // 2. 外层循环: 外层循环时从1位置开始，依次遍历到最后
  for(var i = 1; i < length; i++){
    // 3. 记录选出的元素，放在变量temp中
    var j = i
    var temp = this.array[i]
    // 4. 内层循环: 内层循环不确定循环的次数，最好使用while循环
    while(j > 0 && this.array[j-1] > temp){
      this.array[j] = this.array[j-1]
      j--
    }
    // 5. 将选出的j位置，放入temp元素
    this.array[j] = temp
  }
}
```
* 代码解析
  * 代码序号1: 获取数组的长度
  * 代码序号2: 外层循环，从1位置开始，因为0位置可以默认看成是有序的
  * 代码序号3: 记录选出的i位置的元素，保存在变量temp中，i默认等于j
  * 代码序号4: 内层循环
    * 内层循环的判断j-1位置的元素和temp比较，并且j > 0
    * 那么就将j-1位置的元素放在j位置
    * j位置向前移
  * 代码序号5: 将目前选出的j位置放置temp元素
### 插入排序的效率
* 插入排序的比较次数:
  * 第一趟时，需要的最多次数是1，第二天最多次数是2，依次类推，最后一趟是N-1次
  * 因此是 1 + 2 + 3 +... + N-1 = N*(N-1)/2
  * 然而每趟发现插入点之前，平均只有全体数据项的一半需要进行比较
  * 我们可以除以2得到 N*(N-1)/4 所以相对于选择排序，其他比较次数是少了一半
* 插入排序的复制次数
  * 第一趟时，需要的最多复制次数是1，第二趟最多次数是2，依次类推，最后一趟是N-1次
  * 因此复制次数最多是 1 + 2 + 3 +... + N-1 = N*(N-1)/2
  * 平均次数 N*(N-1)/4
* 对于基本有序的情况
  * 对于已经有序或基本有序的数据来说，插入排序要好很多
  * 当数据有序的时候，while循环的条件总是为假，所以它变成了外层循环中的一个简单语句，执行N-1次
  * 在这种情况下，算法运行至需要N(N)的时间，效率相对来说会更高
  * 比较次数是选择排序的一半，所以这个算法的效率是高于选择排序的