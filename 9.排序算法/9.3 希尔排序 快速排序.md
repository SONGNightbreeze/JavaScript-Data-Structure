### 希尔排序
* 希尔排序时插入排序的一种高效的改进版，并且效率比插入排序要更快
* 希尔排序的历史背景:
  * 希尔排序按其设计者希尔的名字命名，该算法由1959年公布
  * 优秀的排序算法首要条件就是速度
  * 在简单排序出现后的很多一段时间内，人们发明了各式各样的算法
  * 但是最终发现算法的时间复杂度都是O(N^2)，似乎没法超越
  * 此时，计算机学术界充斥着"排序算法不可能突破O(N^2)"的声音
  * 就像之前普遍认为人类100米短跑不可能突破10秒大关
  * 终于有一天，科学家发布超越了O(N^2)的新排序算法
  * 紧接着出现了好几种可以超越O(N^2)的排序算法，后面要学的快速排序也是其中之一
* 所以所有的限制都是从自己的内心开始的

### 希尔排序的思路
* 插入排序的问题
  * 回顾插入排序
    * 由于希尔排序基于插入排序，所以有必须回顾一下前面的插入排序
    * 我们设想一下，在插入排序执行到一半的时候，标记符左边这部分数据项都是排好序的，
      而标记符右边的数据项是没有排序的
    * 这个时候，取出指向的那个数据项，把他存储在一个临时变量中，接着，从刚刚移除的位置左边第一个单元开始
      每次把有序的数据项向右移动一个单元，知道存储在临时变量中的数据项可以成功插入
  * 插入排序的问题:
    * 假设一个很小的数据项在很靠近右端的位置上，这里本来应该是较大的数据项的位置
    * 把这个小数据项移动到左边的正确位置，所有的中间数据项都必须向右移动一位
    * 如果每个步骤对数据项都进行N次复制，平均下来是移动N/2，N个元素就是 N*N/2 = N^2/2
    * 所以我们通常认为插入排序的效率是O(N^2)
    * 如果有某种方式，不需要一个个移动所有中间的数据项，就能把较小的数据项移动到左边，
      那么这个算法的执行效率就会有很大的改进

* 希尔排序的思路
  * 比如下面的数字，81，94，11，96，12，35，17，95，28，58，41，75，15
    * 不正确的分组方式 (81,94,11),(96,12,35),(17,95,28),(58,41,75),(15)
    * (11,81,94),(12,35,96),(17,28,95),(41,58,75),(15) 
    * 好像变成局部有序，但是还是需要一点一点向上移动，而且15依然在最后要移动很多次
    * 正确的方式:
    * 让间隔为5进行排序 然后组内进行排序 
    * (35,18),(94,17),(11,95),(96,28),(12,58),(35,41),(17,75),(95,15)
    * 排序后的新序列，一定可以让数字离自己的正确位置更进一步
    * 最终达到的效果就是: 35，17，11，28，12，41，75，15，96，58，81，94，95
    * 我们再让间隔为3，然后再组内进行排序 (35,28,75,58,95),(17,12,15,81),(11,41,96,94)
    * 对间隔3进行局部排序后: 28，12，11，35，15，41，58，17，94，75，81，96，95
    * 排序后的新序列，一定可以让数字离自己的正确位置又近一步
    * 最后，让间隔为1，也就是正确的插入排序: 11，12，15，17，28，35，41，58，75，81，94，95，96
    * 这个时候数字都离自己的位置更近，那么需要复制的次数一定会减少很多
    81，94，11，96，12，35，17，95，28，58，41，75，15
    5-间隔 35，17，11，28，12，41，75，15，96，58，81，94，95
    3-间隔 28，12，11，35，15，41，58，17，94，75，81，96，95
    1-间隔 11，12，15，17，28，35，41，58，75，81，94，95，96

### 希尔排序的增量
* 选择合适的增量:
  * 在希尔排序的原稿中，他建议的初始间距是N/2，简单的把每趟排序分成两半
  * 也就是说，对于 N = 100 的数组，增量间隔序列为: 20,25,12,6,3,1
  * 这个方法的好处是不需要再开始排序前为找合适的增量而进行任何的计算
* Hibbard增量
  * 增量的算法为2^k - 1，也就是为1 3 5 7..等
  * 这种增量的最坏复杂度为O(N^3/2)，猜想的平均复杂度为O(N^5/4)，目前尚未证明
* Sedgewick增量序列
  * {1,5,19,41,109,...}，该序列中的项或者是 94^i-9*2^i+1 或者是 4^i-32^i+1
  * 这种增量的最坏复杂度为O(N^4/3)，平均复杂度为O(N^7/6)，但是均未被证明

### 希尔排序的代码
```js
ArrayList.prototype.shellSort = function(){
    // 1. 获取数组的长度
    var length = this.array.length
    // 2. 根据长度计算增量
    var gap = Math.floor(length/2)
    // 3. 增量不断变小，大于0就继续排序
    while(gap > 0){
        // 4. 实现插入排序
        for(var i = gap; i< length; i++){
            // 4.1 保存临时变量
            var j=i
            var temp = this.array[i]
            // 4.2 插入排序的内层循环
            while(j > gap-1 && this.array[j - gap] > temp){
                this.array[j] = this.array[j - gap]
                j -= gap
            }
            // 4.3 将选出的j位置设置为temp
            this.array[j] = temp
        }
        // 5. 重新计算新的间隔
        gap = Math.floor(gap/2)
    }
}

```
* 代码解析
  * 代码序号1: 获取数组的长度
  * 代码序号2: 计算第一次的间隔，我们按照希尔提出的间隔实现
  * 代码序号3: 增量不断变小，大于0就继续改变增量
  * 代码序号4: 实际上就是实现了插入排序
    * 代码序号4.1: 保存临时变量，j位置从i开始，保存该位置的值到变量temp中
    * 代码序号4.2: 内层循环，j > gap - 1 并且 temp大于 this.array[j-gap]，那么就继续复制
    * 代码序号4.3: 将j位置设置为变量temp
  * 代码序号5: 每次while循环后都重新计算新的间隔

### 希尔排序的效率
* 希尔排序的效率
  * 希尔排序的效率根增量是有关系的
  * 但是，他的效率证明非常困难，甚至有些增量的效率到目前依然没有被证明出来
  * 但是经过统计，希尔排序使用原始增量，最坏的情况下时间复杂度为O(N^2)，通常情况下都要好于O(N^2)
* 总之，我们使用希尔排序大多数情况下效率都高于简单排序
  * 这个可以通过统计排序算法的时间来证明
  * 甚至在合适的增量和某些数量N的情况下，还好于快速排序

### 快速排序
* 快速排序几乎可以说是目前所有排序算法中，最快的一种排序算法
  * 当然，没有任何一种算法是在任意情况下都是最优的
  * 比如希尔排序确实在某些情况下可能好于快速排序
  * 但是大多数情况下，快速排序还有比较好的选择
* 快速排序的重要性:
  * 如果有一条模式的时候，让写一个排序算法
  * 可以写出多个排序算法，但是如果其中没有快速排序
  * 那么证明你对排序算法也只是浅尝辄止，并没有深入的研究过
  * 因为快速排序可以说是排序算法中最常见的，无论是C++的STL中，还是Java的SDK中其实都能找到他的影子
  * 快速排序也被列为20世纪十大算法之一
* AnyWay，快速排序非常重要

### 快速排序的思想
* 希尔排序相当于插入排序的升级版，快速排序其实是我们学习过最慢的冒泡排序的升级版
  * 冒泡排序需要经过很多次交换，才能在一次循环中，将最大值放在正确的位置
  * 而快速排序可以在一次循环中(其实是递归调用)，找出某个元素的正确位置，并且该元素之后不需要任何移动
* 快速排序的最重要的思想是分而治之
* 比如下面这样一堆数组需要排序:
  * 第一步: 从其中选出了65，(其实可以是选出任意的数字，以65举个例子)
  * 第二步: 我们通过算法: 将所有小于65的数字放在65的左边，将所有大于65的数字放在65的右边
  * 第三步: 递归的处理左边的数据，(比如你选择31来处理左侧)，
            递归的处理右边的数据(比如选择75来处理右侧，当然选择81可能更合适)
  * 最终: 排序完成
* 和冒泡排序不同的是什么呢?
  * 我们选择的65可以一次性将他放在最正确的位置，之后不需要任何移动
  * 需要从最开始位置两个两个比较，如果第一个就是最大值，他需要一直向后移动，知道走到最后
  * 也就是即使已经找到了最大值，也需要不断继续移动最大值，而插入排序对数字的定位是一次性的

### 快速排序的思路
* 选择一个枢纽，让枢纽和最后一个位置或者最前面的一个位置进行交换
* 将枢纽放在最后一个位置，从左右两边分别取一个指针开始查找元素
* 指针left从最左边开始指向的是第一个元素，指针right从最右边开始指向的是倒数第二个元素(因为倒数第一个是枢纽)
* 左边的指针找比枢纽大的数字，找到之后指针停掉，从右边找比枢纽小的数字，找到之后指针停掉
* 进行交换: 将左边指针指向的数字和右边指针指向的数字位置交换
* 左边的指针和右边的指针再继续向下查找
* 值到两个指针重叠的时候，将这个指针位置的元素和13进行交换
* 现在再在左边和右边分别选择另外的枢纽，重复上面的查找交换

* 快速排序的枢纽
  * 在快速排序中有一个很重要的步骤就是选取枢纽(pivot也有人称为主元)
    * 如何选择才是最合适的枢纽呢?
  * 一种方案是直接选择第一个元素作为枢纽
    * 但第一个作为枢纽在某些情况下，效率并不是特别高
  * 另一种方案是使用随机数
    * 随机取pivot? 但是随机函数本身就是一个耗性能的操作
  * 另一种比较优秀的解决方案: 取头、中、尾的中位数
    * 例如 8、12、3 的中位数就是 8
    * left = 0， right = length - 1， center = (left+right)/2  
    * 然后将最大值放到最后，中位数放到倒数第二个位置，
    * 因为最后排序大于中位数的值也一定会在中位数右侧，可节省一些移动
### 代码的实现
```jsx
ArrayList.prototype.shellSort = function () {
    // 1.获取数组的长度
    var length = this.array.length

    // 2.根据长度计算增量
    var gap = Math.floor(length / 2)

    // 3.增量不断变量小, 大于0就继续排序
    while (gap > 0) {
        // 4.实现插入排序
        for (var i = gap; i < length; i++) {
            // 4.1.保存临时变量
            var j = i
            var temp = this.array[i]

            // 4.2.插入排序的内层循环
            while (j > gap - 1 && this.array[j - gap] > temp) {
                this.array[j] = this.array[j - gap]
                j -= gap
            }

            // 4.3.将选出的j位置设置为temp
            this.array[j] = temp
        }
      
        // 5.重新计算新的间隔
        gap = Math.floor(gap / 2)
    }
}
```
* 代码解析
  * 代码序号1: 获取数组的长度
  * 代码序号2: 计算第一次的间隔, 我们按照希尔提出的间隔实现.
  * 代码序号3: 增量不断变小, 大于0就继续改变增量
  * 代码序号4: 实际上就是实现了插入排序
  * 代码序号4.1: 保存临时变量, j位置从i开始, 保存该位置的值到变量temp中
  * 代码序号4.2: 内层循环, j > gap - 1并且temp大于this.array[j - gap], 那么就进行复制.
  * 代码序号4.3: 将j位置设置为变量temp
  * 代码序号5: 每次while循环后都重新计算新的间隔.

### 快速排序的效率
* 快速排序的最坏情况效率
  * 什么情况下会有最坏的效率? 就是每次选择的枢纽都是最左边或者最后边的
  * 那么效率等同于冒泡排序
  * 而我们的例子可能有最坏的情况么?是不可能的，因为我们是选择三个值的中位值
* 快速排序的平均效率:
  * 快速排序的平均效率是O(N*logN)
  * 虽然其他某些算法的效率也可以达到O(N*logN)，但是快速排序时最好的
```js
// 创建列表类
function ArrayList(){
    // 属性
    this.array = []
    // 方法
    // 将数据可以插入到数组中的方法
    ArrayList.prototype.insert = function(){
        this.array.push(item)
    }
    // toString  调用上面insert方法的时候，toString方法也会执行
    ArrayList.prototype.toString = function(){
        return this.array.join('-')
    }
    // 交换数据的方法
    ArrayList.prototype.swap = function(m,n){
      var temp = this.array[m]
      this.array[m] = this.array[n]
      this.array[n] = temp
    }

    // 实现排序算法
    // 冒泡排序
    ArrayList.prototype.bubbleSort = function(){
      // 第一次: j = length - 1，比较到倒数第一个位置
      // 第二次：j = length - 2, 比较到倒数第二个位置
      // ...
      var length = this.array.length;
      for (var j = length -1; j >= 0; j--){
        for(var i = 0; i < j; i++ ){
          if(this.array[i] > this.array[i+1]){
            this.swap(i,i+1)
          }
        }
      }
    }

    // 选择排序
    ArrayList.prototype.selectionSort = function(){
      // 1. 获取数组长度
      var length = this.array.length

      // 2. 外层循环从0位置开始取数据
      for (var j = 0; j < length - 1; j++){
        var min = j
        // 内层循环，从i+1位置，开始和后面的数据进行比较
        for(var i = min + 1; i < length; i++){
          if(this.array[min] > this.array[i]){
            min = i
          }
        }
        this.swap(min, j)
      }
    }
    
    // 插入排序
    ArrayList.prototype.insertionSort = function(){
      // 1. 获取数组的长度
      var length = this.array.length
      // 2. 外层循环: 从第1个位置开始获取数据，向前面局部有序插入
      for(var i = 1; i<length; i++){
        // 3. 内层循环: 获取i位置的元素，和前面的数据依次进行比较
        var temp = this.array[i]
        var j = i
        // 因为不知道比较次数，所以使用while不用for
        // this.array[j-1] 就是i前面的那个位置数据
        while(this.array[j - 1] > temp && j > 0){
          // 如果前面位置的数据大于现在位置的数值，就进行一个位移
          this.array[j] = this.array[j - 1]
          j--
        }
        // 4. 将j位置的数据，放置temp就可以了
        this.array[j] = temp
      }
    }

    // 希尔排序
    ArrayList.prototype.sheeSort = function(){
        // 1. 获取数组的长度
        var length = this.array.length
        // 2. 初始化增量
        var gap = Math.floor(length/2)
        // 3. while循环(gap不断的减小)
        while(gap >=1){
            // 插入排序
            // 4. 以gap作为间隔，进行分组，对分组组内进行插入排序
            for(var i = gap; i< length; i++){
                // 可以进行内层循环
                // 获取i位置元素和之前的元素依次进行对比
                var temp = this.array[i]
                var j = i
                while(this.array[j-gap] > temp && j > gap-1){
                    // 相当于将j位置的元素赋值给 j-gap位置的元素，相当于将81赋值到35的位置上
                    this.array[j] = this.array[j - gap]
                    j -= gap
                }
                // 5. 将j位置的元素赋值给temp
                this.array[j] = temp
            }
            // 6. 增量变化 /2
            gap = Math.floor(gap/2)  // 作为循环判断的值，每次循环完后增量都除2再进行分组
        }
    }
    // 快速排序
    // 1. 选择枢纽
    ArrayList.prototype.median = function(left,right){
        // 1.取出中间的位置  Math.floor()向下取整
        var center = Math.floor((left+right)/2)
        // 2.判断大小，并且进行交换
        if(this.array[left] > this.array[center]){
            // 如果左边的元素大于中间的元素，就进行一个交换
            this.swap(left,center)
        }
        if(this.array[center] > this.array[right]){
            // 如果中间的元素大于右侧的元素，进行一个位置交换
            this.swap(center,right)
        }
        if(this.array[left] > this.array[right]){
            this.swap(left, right)
        }
        // 现在最大的值已经放在了最右侧
        // 现在将中间的位置和倒数第二个位置的元素进行交换，
        // 因为最右侧的元素(最后一个元素)已经判断出大于中位数位置的元素，节省交换次数，不需要再交换
        // 3. 将center换到right-1的位置作为枢纽
        return this.array[right-1]
    }
    // 2. 快速排序的实现
    Array.prototype.quickSort = function(){
        // 传入最左边和最右边的值，因为已经获取到了中位值并且做了交换
        // 所以传入的是最左边的值，和倒数第二个值，
        // 因为最右边的值一定是大于中位数的，在获取枢纽的时候就已经交换完成
        // 然后在递归函数内依次开始查找交换
        this.quick(0,this.array.length-1)
    }
    // 递归函数
    Array.prototype.quick = function(left,right){
        // 1. 结束条件，当left大于right的时候就可以结束
        if(left >= right) return 
        // 2. 获取枢纽
        var pivot = this.median(left, right)
        // 3. 定义变量，用于记录当前找到的位置
        var i = left
        var j = right - 1
        
        // 4. 开始进行交换 
        while(true){
            // 因为在查找枢纽的时候就已经做了比较和交换，
            // 第一个位置的元素一定小于枢纽所以可以忽略掉第一个，这里从 ++i 开始查找
            // 如果是小于枢纽的就继续向下找，不需要任何操作
            // 直到找到某个值是大于枢纽，就会停掉
            while(this.array[++i] < pivot){}
            // 从左边找的时候停掉以后，就从右边开始查找是否大于枢纽
            // 当某个值小于枢纽的时候，也会停掉
            while(this.array[--j] > pivot){}
            // 当从左边找到大于枢纽的值，从右边找到小于枢纽的值的时候，开始做下面的判断
            // 如果左边查找的值小于右边的查找就进行一个交换
            if(i < j){
                this.swap(i,j)
                // 交换之后左右继续往后查找
            }else{
                // 一点i>j就退出循环，表示右边的查找已经越过左边查找i的位置，
                // 多数值就已经找到正确的位置了，到现在就停止，然后到循环外层将i和枢纽交换即可
                // 因为这个时候i是大于j的
                break;
            }
        }
        // 这里是左边开始查找到某个值大于枢纽，右边开始查找的时候小于某个枢纽，
        // 并且左边的大于右边的值，说明现在 左边的值最大，大于右边的值，并且也大于枢纽
        // 就做下面的交换
        // 6. 将枢纽放置在正确的位置，i的位置
        this.swap(i,right-1)
        // 7. 分而治之
        //    左边的部分进行递归调用
        this.quick(left, i-1)
        //    右侧的依次进行递归调用
        this.quick(i + 1,right)
    }
}
// 测试类
var list = new ArrayList()
// 插入元素
list.insert(66)
list.insert(88)
list.insert(12)
list.insert(87)
list.insert(100)
list.insert(5)
list.insert(566)
list.insert(23)
alert(list)  // 输出 66-88-12-87-100-5-566-23
// 验证希尔排序
list.sheeSort()
alert(list)  // 输出 5-12-23-66-87-88-100-566

// 验证快速排序
list.quickSort()
alert(list)  // 输出 5-12-23-65-87-88-100-566
```